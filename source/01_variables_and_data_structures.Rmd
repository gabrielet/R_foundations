---
title: "Think like a programmer - an introduction"
date: "`r format(Sys.time(), '%A %d, %B')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    theme: readable
    colortheme: "default"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, results="hide", fig.show="show")
```

# Short intro to R

R is a programming language which is mainly used for statistical purposes but in reality it has many more applications. R exists in a base form, offering a wide set of tools, which are called *functions*, that are used to perform many operations such as computing means, plotting, regression analysis, and much more.

In addition, there are many packages, e.g. *ggplot2*, *phyloseq*, *Vegan*, ..., that were created to extend the basic set of R functions for more specific tasks.  DNA sequences analysis, gene enrichments analysis, network construction, advanced plotting, computing \alpha-diversity, etc...

Of course, packages need to be installed before using them. packages can be found [in several places](https://rdrr.io/find/?repos=cran%2Cbioc%2Crforge%2Cgithub&fuzzy_slug=), such as CRAN, R-Forge, Github, or Bioconductor. packages can be installed from all these sources and then it will be possible to take advantage of the functionalities they offer.

# Super short into to RStudio

RStudio is and Integrated Development Environment (IDE) that allows you to run R scripts, edit them in a text editor, visualise and export results and plots, look into tables, create and compile Markdown-based documents (such as this document we're using), and many more things.

If you don't want to use RStudio you can use R from the command line and write your scripts using a text editor.

# Think like a programmer

Programming may seems complicated at first, and R is not the best way of learning it (there are programming languages that are easier to understand), but it's not about the language. Programming is a different way of thinking how problems can be solved.

In programming you should think through logic statements and loops.

Programming means putting together a set of instructions, lets call it a *program* or a *script*, that will return the expected result. These instructions *have to*:

-   be ordered, since it is not possible to read a book with random sentences;
-   follow that-programming-language specific rules.

These instructions *should be*:

-   as simple as possible;
-   well commented so (you and) other peoples can understand it in the future.

# Building blocks of programming

## R environment

When we first start a session of R, we must be aware that R is _sitting_ in a specific folder in our computer. You can, of course, specify which folder this folder is, but you need to be aware. So...which folder are you currently in, i.e. the working directory? Let's ask R using the function `getwd()` which basically _gets the Working Directory_.

```{r}

# where am I??
getwd()

```

If this is not the directory you want to be working in, and there are many reasons for that, you can always change it using another function which is `setwd()`, which basically _sets a Working Directory_:

```{r}

# move to the folder containing the data for this course
setwd("/home/gabriele/work/microbiology/think_like_a_programmer/")

```

Now that we set the working directory, it's time to get to know the R environment, which represent the sets of variables, functions, and packages that are available to you in a specific R session. To get these information we can use two functions: `ls()` and `search()`:

```{r}

# show objects I can use
ls()

# show packages I can use
search()

```

The working directory, and the working environment are very important. We will get back to this later on, though.

## Variables

A variable can be seen as a box that contains zero, one, or many things which can be used, modified, and deleted whenever you like.

You have probably heard about variables. Variables are used, for example, in mathematics to represent unknown values in equations:

$3x + \frac{1}{2} y = 0$

In this case $x$, $y$ are the names of two different variables. It means they can take, _theoretically_, any value. The same applies in R: a variable can be _substituted_, or can _contain_ any value.

When you use, or _call_, a variable, what you are actually doing is using the value that is contained in it.

So, a variable is like a box which can contain something that you want to use later on. That is why you put it into the box: it's just a storage. When you need whatever was inside the box, you will know where to find it and how it's called.

The action is performed _on_ the content of the box. Of course, if something is not needed later on, you don't define a variable for it: it's a waste of space (how many things you have in boxes that are never used and just takes space??).

Assigning a value to a variable in R:

```{r}

# assign a value using left arrow
a_value <- 5
a_value

# assign a value using right arrow
10 -> another_value
another_value

# assign a value using equal
a_third_value = 15
a_third_value

# assign two values at once
left_assign <- 100 -> right_assign
left_assign
right_assign

```

All of these assignments are valid. However, the symbol `=` is usually found only when a value is _passed_ to a parameter (we will see this!), while the left arrow, i.e. `<-`, is the preferred one. The right arrow can also be used but it's very uncommon.

### Data types

In R there are several data types, each one with its own characteristics. A general distinction can be made by separating data types in _numerical_ and _categorical_.

### Numerics

Numerics, as you may expect, are numbers. Numbers which can be used to perform mathematics (, statistics, and much more). Numerics can be either integers or double (if they have decimals).

Example of numerics:

```{r}

# define a variable named one and assign an integer to it
one <- 1

# define a variable named three_point_five and assign a double
three_point_five <- 3.5

# sum up one and three_point_five, you will get a double
one + three_point_five

# same result can be obtained by summing up 1 and 3.5
1 + 3.5

```

Numerics can be stored inside variables and then used for operations, at any point in the code, but only after they were _declared_, i.e. after they actually exist.

The only thing you need to remember is the name of the variable where the numeric was stored. So, to keep things simple, let's start using meaningful names for your variables (we already were doing it, anyway), to remember what they contain.

You can now use the variables that were defined above, to perform some more operations:

```{r}

# some more random operations
one + 3.5

three_point_five / 3

one * three_point_five

```

### Characters

Characters, on the other hand, represents those _symbols_ that are not numbers. So, for example, letters and words.

Example of characters:

```{r}

# define a variable named a_characters containing a single character
a_character <- "c"

# define a variable where many characters are pasted together
# let's call this a string
some_characters <- "manycharacters"

```

Clearly, arithmetic operations can be only performed on numbers, i.e. numerics. It does not make sense to sum up characters, or does it?

```{r error=TRUE}

# sum (the content of) some_characters and 1
some_characters + 1

```

Here, R is telling you that something is wrong. The errors arose because you are trying to use a non-numeric object, i.e. the variables `some_characters` to perform some arithmetic operations (a sum).

The interesting thing with `characters`, is that they can be concatenated to form more complex sequences of `characters`. To do this, we need to introduce a new function: `paste()` that allows you _combining_ the content of variables together.

For example, let's define a path to a folder in your computer:

```{r}

# path to Desktop folder
path_to_folder <- "/home/gabriele/Desktop/"

# show the path
path_to_folder

# path to work-related stuff. put together path_to_folder with the
# name of the work folder:
path_to_work_folder <- paste(path_to_folder, "work_folder/", sep="")

# show the path
path_to_work_folder

# path to pics from the last vacation. same as for the work folder
path_to_vacations_pics_foder <- paste(path_to_folder, "vacations_pics/")

# show the path
path_to_vacations_pics_foder

```

In this way you can define a common path, `path_to_folder`, and build more complex paths on top of it. That's how variables can be pasted:

```{r}

# set result in advance
five <- 5

# now sum three + two
print(paste("three plus two equals", five))
```

You can combine any kind of variable with `paste()` but results, sometimes, can be surprising!

#### A very nice exercise

Use the function `ls()` to show the content of _path_to_folder_ and _path_to_work_folder_. Then, move the current working directory (remember `getwd()`) to _path_to_folder_.

### Factors

Factors may be look like characters, but they have other properties as well.

Examples of factors:

```{r error=TRUE}

# these are characters
some_characters <- "some_characters"

# define a factor using a sequence of characters
a_factor <- as.factor(some_characters)

```

Factors can be used to represent categorical variables (in the statistical sense). Categorical variables can be Nominal or Ordinal. For instance, let's define a nominal categorical variable that contains many different (sequences of) characters, such as:

```{r}

# list some friends
friends <- c("Francesca", "Valerio", "Sofia", "Elena")

# cast friends to factor
friends <- factor(friends)

# show the content of the variable
friends

# add other friends, while keeping same levels
friends <- c("Francesca", "Valerio", "Sofia", "Elena", "Francesca", "Valerio")
friends <- factor(friends)
friends

```

Now let's define an ordinal categorical variable, instead:

```{r}

# list soil depths
depths <- c("surface", "medium", "deep", "shallow", "very_deep")

# cast depths as factor and order it (it's ordinal, right?)
depths <- factor(depths, order=TRUE, levels=c("very_deep", "deep", "medium", "shallow", "surface"))

# show the content of the variable
depths

```

There is an interesting difference between `friends` and `depths`. The first one has levels that are ordered, by default by R, alphabetically (you can still order them as you like). They are names, they don't have a strict order, no one is bigger, slower, higher, or weigh more than another: just names.

On the other hand, soil levels are ordered: *verydeep* is deeper than *medium* which, in turn, is deeper than *shallow*. Here, the order is important. That's why you may want to set the levels (this is very handy when performing statistical analysis such as linear regression or other stuff such as plotting).

## Side note about Casting

To _cast_ (or _casting_) means transforming an object of a type into an object of another type, as we just did using the function `as.factor()`. Another example can be done using the function `as.integer()`. This function transforms something into an integer, if it is possible:

```{r}

# transform a double into integer
as.integer(2.3)

# transform a character into an integer and sum two
as.integer("1") + 2

# transform another character into an integer
# (this will give you an error since the letter A does not correspond to any number!)
as.integer("A")

```

Interestingly, you can perform operations using factors:

```{r}

# shall we sum up some depths?
sum(as.integer(depths))

```

### Logicals

Logical can take values that are either `TRUE` or `FALSE`. They are fundamental in programming because contrary to human logic, computer logic works with zero and one, black or white: in programming a _statement_ can be `TRUE` or `FALSE`.

Logical values have specific operations that are performed through logical operators. They are three: AND, OR, and NOT. In R, they are written as symbols which you can find on your keyboard:

-   AND: `&`;
-   OR: `|`;
-   NOT: `!`.

`TRUE` can be abbreviated as `T`, `FALSE` as `F`.

To understand how they work let's start with the AND operator. The AND operator takes two logical values as input, and return TRUE when both are TRUE. We can translate this as: "I will be happy if I can have popcorn and a zombie movie!".

```{r}

# true and true
TRUE & TRUE

# true and false
TRUE & F

# false and true
FALSE & T

# false and false
F & F

```

The OR operator works in the same way as the AND operator but it returns TRUE if one of the two logical values is TRUE. We can translate this as: "I will be happy if I can have either a hot chocolate or a coffee with whip cream".

```{r}

# true or true
T | T

# true or false
TRUE | FALSE

# false or true
F | TRUE

# false or false
F | FALSE

```

The NOT operator is a negation of the logical operator it is used with logical values or functions:

```{r}

# not true
!T

# not false
!F

# is 4 a numeric??
four <- "four"
is.numeric(four)

# or, is it not??
!is.numeric(four)

# wait, but is it or is it not??
!!is.numeric(four)

```

There are other operators that are used for comparing objects: 

 - equal to: `==`;
 - not equal to: `!=`;
 - greater than: `>`;
 - greater than or equal to: `>=`;
 - smaller than: `<`;
 - smaller than or equal to: `<=`.

A few examples:

```{r}

# equal to
"hello" == "ciao"

# equal to
4 == 5

# not equal to
10 != 100

# smaller than
4 < 5

# greater than or equal to
100 >= 10

# you can also combine expressions
10 > 9 | "a" == "b"

10 < 9 & 5 > 4

10 >= 9 | 5 < 4

```

Finally, there are some functions that _return_, i.e. they give as output or as a result, a logical value. An example of such functions is `which()`.

We will see how logical values and operators work when used in actual loops.

#### Vectors of logical values

Logical values can be combined in vectors:

```{r}

# define two vectors of logical values
logi_vals_one <- c(TRUE, TRUE, FALSE)

logi_vals_two <- c(FALSE, TRUE, FALSE)

# test the AND logical operator on the vectors
logi_vals_one & logi_vals_two

# test the OR logical operator on the vectors
logi_vals_one | logi_vals_two

# test the NOT logical operator on the vectors
!logi_vals_one
!logi_vals_two

```

## Data structures

So far we have seen numerics, characters, and logical values (and actually a few vectors), which can be considered as the basis which you can use to build more complex data structures. At this point it is safe to say that a data structure is a container for a set of objects.

### Vectors

Vectors are variables containing more than one object. They are like sets. Let's look in detail what it means:

```{r}

# define a character variable, which is actually a vector
friends <- c("Francesca", "Valerio", "Sofia", "Elena")

# print the content of friends
paste("the content of friends is ", friends, sep="")

```

`friends` is a vector, i.e. a data structure. The vector `friends` was built using the function `c()` that basically combines the strings that were used as input. In `friends` we put four values. You can get this information using a function that show you the _length_, or the number of elements, in a vector. The function, as you may have guessed, is `length()`.

```{r}

# how many elements are there in friends?
length(friends)

# print the objects contained in the vector called friends
print(paste0("the first object in contact is ", friends[1]))
print(paste0("the second object in contact is ", friends[2]))
print(paste0("the third object in contact is ", friends[3]))
print(paste0("the fourth object in contact is ", friends[4]))

```

### Lists

Lists are variables containing more than one object, as vectors. However, contrary to vectors lists need to be defined before using them. This means that first you need to define an empty list, then you can fill it:

```{r}

# define an empty list
a_list <- list()

# add something to the list, i.e. a numerical value
a_list[["a_number"]] <- 121.36509356

# add something more to the list, i.e. some characters
a_list[["some_chars"]] <- "somechars"

# print the content of the list
a_list

```

Ok, but what is the difference between lists and vectors, then? To answer this question let's look into the type of objects that you can store into a list and into a vector.

```{r}

# define vector of numerics
numerics_vect <- c(1, 1.24587, 45, 39372.2134)

# define a vector of characters
friends <- c("Francesca", "Valerio", "Sofia", "Elena")

# define a vector of numerics AND characters (can we??)
nums_and_chars <- c("one", 2, "three", 4, 5)

# print the content of the vectors we just created
numerics_vect
friends
nums_and_chars

```

If we look at the `nums_and_char` vector, you will notice something weird: numerics are quoted. This means that they are not numerics anymore. They were casted, automatically by R, into characters (because R can't cast a character into a numeric).

The problem, for R, is that you cannot create a vector containing different data types, i.e. characters and numerics together. This, however, can be achieved through `lists`:

```{r}

# define empty list
a_complex_list <- list()

# fill the list
a_complex_list[["drawer_one"]] <- "one"
a_complex_list[["drawer_two"]] <- 2
a_complex_list[["drawer_three"]] <- "three"
a_complex_list[["drawer_four"]] <- 4
a_complex_list[["drawer_five"]] <- 5

# show the content of the list
a_complex_list

```

In this case, numerics are not quoted. They are still numerics! Just to test if that's true:

```{r}

# print the type of data contained in all the drawers of the list
print(c(typeof(a_complex_list[["drawer_one"]]), typeof(a_complex_list[["drawer_two"]]), typeof(a_complex_list[["drawer_three"]]), typeof(a_complex_list[["drawer_four"]]), typeof(a_complex_list[["drawer_five"]])))

# same for the vector
print(c(typeof(nums_and_chars[1]), typeof(nums_and_chars[2]), typeof(nums_and_chars[3]), typeof(nums_and_chars[4]), typeof(nums_and_chars[5])))

```

In the first case different types are shown. In the second case...always characters: that's the difference between lists and vectors.

## Dataframes and matrices

Now that vectors, lists, and data types were introduced, it's time to put these things together into matrices and data frames. The main difference between matrix and dataframes is the same we have seen for lists and vectors. Matrices can contain only one type of data, while dataframes can contain different kind of data.

### Matrices

On the one hand, we have matrices:

```{r}

# define a matrix of zeroes
a_matrix_of_numbers <- matrix(0, nrow=3, ncol=4)

# define a matrix of chars
a_matrix_of_chars <- matrix("0", nrow=3, ncol=4)

# show the variables content
a_matrix_of_numbers
a_matrix_of_chars

# assign a character to a_matrix_of_numbers
a_matrix_of_numbers[1, 1] <- "0"

# show the content of the variable
a_matrix_of_numbers

```

After substituting an element of `a_matrix_of_numbers` with a character, i.e. "0", all the other zeros were casted into chars. As we said, a matrix can only contain a specific data type.

With this example, we also introduced the word _substituting_ an element of the matrix. The substitution, or _assignment_ happened here:

```{r}

# set value in position (1, 1)
a_matrix_of_numbers[1, 1] <- "0"

```

By doing so, you are accessing the value in the matrix, i.e. row 1, column 1, and putting something _into_ it, or _assigning_. In other words you _substitute_ or _overwrite_ the previous content.

Of course, you can access whole matrices, a single cell (as we just did), a whole row, or a whole column. The general notation follows this pattern `matrix[n_of_row, n_of_column]`:

-   If we specify `n_of_row` **and not** `n_of_column`, i.e. `a_matrix[1, ]`, we are accessing the first row, all the columns. We are getting the whole first row;
-   If we specify `n_of_column` **and not** `n_of_row`, i.e. `a_matrix[, 1]`, we are accessing the first column, all the rows. We are getting the whole first column;
-   If we specify both `n_of_row` **and** `n_of_column`, i.e. `a_matrix[1, 1]`, we are accessing a single cell;
-   If we specify both `n_of_row` **and** `n_of_column` but more than one, i.e. `a_matrix[c(1,2), c(3, 4)]`, we are accessing a subset of cells;
-   If we specify nothing, i.e. `a_matrix[,]` **or** `a_matrix`, we are accessing the whole matrix;

Let's make an example with numbers:

```{r}

# define a matrix with 3 cols and 4 rows, with numbers from 1 to 12
# (we have 12 cells, right? and R will fill the matrix for us)
a_matrix_of_numbers <- matrix(c(1:12), ncol=3, nrow=4)

# print
a_matrix_of_numbers

# now, let's grab the second row, all the columns
a_matrix_of_numbers[2, ]

# now, let's grab the second column, all the rows
a_matrix_of_numbers[, 2]

# now, let's grab the second row, third column
a_matrix_of_numbers[2, 3]

# now, let's grab the second and fourth rows, the second and third column
a_matrix_of_numbers[c(2, 4), c(2, 3)]

```

Pretty convenient to subset matrices and work with some of the values, if needed!

What is even more convenient, however, is the possibility to assign names to rows and columns:

```{r}

# define a matrix with 3 cols and 4 rows, with numbers from 1 to 12
a_matrix_of_numbers <- matrix(c(1:12), ncol=3, nrow=4)

# use the function rownames to assign names to rows
rownames(a_matrix_of_numbers) <- c("row_one", "row_two", "row_three", "row_four")

# use the function colnames to assign names to columns
colnames(a_matrix_of_numbers) <- c("col_one", "col_two", "col_three")

# remember that the function rownames (and also colnames)
# can be used to visualise columns and rows names
rownames(a_matrix_of_numbers)
colnames(a_matrix_of_numbers)

```

At this point, you can get columns, or rows, by using their names:

```{r}

# get second column
a_matrix_of_numbers[, "col_two"]

# get fourth row
a_matrix_of_numbers["row_four",]

```

Matrices can be combined together, by columns or by rows, using two functions: `cbind()` and `rbind()`:

```{r error=TRUE}

# define a matrix with 3 cols and 4 rows, with numbers from 1 to 12
matrix_one <- matrix(c(1:12), ncol=3, nrow=4)

# define another matrix with 3 cols and 4 rows, with numbers from 1 to 12
matrix_two <- matrix(c(13:24), ncol=3, nrow=4)

# define a matrix with 4 cols and 3 rows, with numbers from 1 to 12
matrix_three <- matrix(c(25:36), ncol=4, nrow=3)

# now merge matrix_one and matrix_two by columns, i.e. use cbind
cbind(matrix_one, matrix_two)

# now merge matrix_one and matrix_two by rows, i.e. use rbind
rbind(matrix_one, matrix_two)

# now try to merge matrix_two and matrix_three by rows, i.e. use rbind
rbind(matrix_two, matrix_three)

```

The last `rbind()` did not work because the matrices has a different number of columns. When putting together matrices, you need to make sure they have the correct dimensions.

### A mathematical side note or How a bug is born

In linear algebra matrices are quite popular. So, it is important to know how to use them to perform common operations such as sum or multiplication, since it may be non obvious. Let's make an example of multiplication:

```{r}

# define a simple 2x2 matrix
simple_matrix <- matrix(c(1,2,3,4), nrow=2, ncol=2)

# define simple vector to multiply the simple matrix
simple_vector <- c(0, 1)

# multiply matrix by vector, "R version"
simple_matrix * simple_vector

# multiply matrix by vector, linear algebra version
simple_matrix %*% simple_vector

```

The difference is that in linear algebra, multiplying a matrix by a vector will give you back a vector. However, using the wrong tool, i.e. `*`, to perform a simple operation may give you unexpected results.

### Dataframes

On the other hand, we have dataframes:

```{r}

# create a dataframe with 4 rows and 2 columns
a_dataframe <- data.frame(some_numbers=c(1, 435, 65432, 7.65376), some_chars=c("Elena", "Sofia", "Valerio", "Francesca"))

# show the content of the dataframe
a_dataframe

```

In this case you defined a dataframe and assigned a name to each of the two columns. This was done by telling to R that `some_numbers` and `some_chars`, i.e. two vectors, should be combined into a `data.frame`. Let's split the process in all its parts:

```{r}

# first, define two vectors
student_mark <- c(10, 8, 8.5, 9)
student_name <- c("Elena", "Sofia", "Valerio", "Francesca")

# second, put the two vectors together as a data frame
students_data <- cbind.data.frame(student_mark, student_name)

# show the content of the dataframe
students_data

```

Here, we used a new function, i.e. `cbind.data.frame()`, because we wanted to put together the two vectors as columns. You could do it by row, i.e. using `rbind.data.frame()` depending on what you need. It's exactly the same we did when we used `rbind` or `cbind` for matrices.

Dataframes, as matrices, can be accessed in several ways. You can access a single cell, a column, a row, or a set of columns and rows by using the same notation, i.e. the square brackets `[1, c(1, 4)]`, but also using row and columns names. In the case of columns, though, it's a bit different with respect to what we did with matrices:

```{r}

# access the numbers column using the $ symbol
students_data$student_mark

# access the numbers column using the $ symbol
students_data$student_name

```

Remember that dataframes can be accessed in all the way matrices can be accessed, but they also have the `$` symbol allowing you to get a column by using its name (we can't use the \$ with matrices). This can be used to add new columns to dataframes in a very simple way:

```{r}

# add new column, as a vector, to an existing dataframe
# by specifying its name
students_data$student_surname <- c("F.", "G.", "M.", "B.")

# show the content of the new dataframe
students_data

```

### Last, small thing about lists

Finally, it is important to remember that, as we have already seen, lists can contain different objects in their cells. Let's make a final example:

```{r}

# create an empty list
another_complex_list <- list()

# add a numeric vector to the list
another_complex_list[["numerics"]] <- c(1, 2, 3, 4, 5)

# add a character vector to the list
another_complex_list[["chars"]] <- c("1", "2", "3", "4", "5")

# add a matrix to the list
another_complex_list[["matrix"]] <- a_matrix_of_numbers

# add a dataframe to the list
another_complex_list[["dataframe"]] <- students_data

# show the content of the list
another_complex_list

```

In this example, a lists is used to create a complex data structure that provide different informations. Each information is stored into it's own cell, with it's own name, to easily access that piece of information when needed.

### A side note about tables

When we talked about matrices and dataframes, what we didn't talk about was how to load existing tables into R (yes, I am talking the data you managed to collect after sampling soil, extracting DNA, sequencing it, and everything in between).

The only thing that we need to know about tables is:

 > when you build a table make sure it is well formatted and save it as _.csv_.

If this rule is applied your life will be easier and you will be happy.

Now, let's load a (well formatted) table from a file, just to see how it's done:

```{r}

# set path to directory where files are kept
path_to_files <- "/home/gabriele/work/microbiology/think_like_a_programmer/ready_for_sharing/download_these_files/data/"

# load a table from a csv file
ecology_data <- read.csv(paste(path_to_files, "meta_data.csv", sep=""), header=T, sep="\t")

# show number of rows and number of columns
nrow(ecology_data)
ncol(ecology_data)

# show these values at once
dim(ecology_data)

# show the first six lines of the loaded table
head(ecology_data)

# show the first ten, but you need to specify it
# since by default the lines that are shown are six
head(ecology_data, n=8)

```

At this point, it's worth introducing three functions that can be used to subset tables. These function take advantage of logical values. In other words, these functions will give you back some values will be `TRUE` or `FALSE`. So, to subset a table you will need to define _what you like_, which will be `TRUE`, and _what you don't like_, which will be `FALSE`.

Let's think like programmers for a second.

Let's say that you want to subset a table to get those samples which treatment is equal to _Control_.

In current language you would say exactly what we just said, i.e. "Which Samples are Controls?".

Well, it turns out that _which_, in R, is an actual function. Indeed, `which()`, allows you to get those values which are equal or not equal to other values.

So, let's get those samples that are Controls:

```{r}

# print table, just to have an idea of what we are dealing with
head(ecology_data)

# get control samples using the which function and a logical operator
which(ecology_data$treatment=="C")

```

What is `which()` telling you? What if I show you this, instead, of the `which()`? How is this related to the result that we got from the `which()` function?

```{r}

# get control samples
ecology_data$treatment=="C"

```

The answer is that the `which()` function is showing you the number of rows of those samples that are controls. The other command, on the other hand, is showing which samples are controls, i.e. `control==TRUE`, and which are not, i.e. `control==FALSE`.

So, now that you know which samples are control and which are not, it's time to use this piece of information to subset the original metadata table:

```{r}

# store control samples in a variable
control_samples_rows <- which(ecology_data$treatment=="C")

# subset ecology_data, by rows, since the which returned
# the number of rows for control samples
ecology_data[control_samples_rows, ]


# or, use the logical vector
control_samples_logical <- ecology_data$treatment=="C"

# subset
ecology_data[control_samples_logical, ]

```

Of course, it is possible to create any combination of conditions, using the logical operators.

#### Two very nice exercises

Subset the table to get only those samples that:

 1. are not Controls;
 2. are Controls sampled in Winter.
